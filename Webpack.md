### Webpack

- Dependency management tool.
- Bundle multiple assets into a smaller group. (Like multiple js, css, png files to single js, css and png file)
- It comes out of the box with CRA.
- We don’t need CRA to use webpack.
- Npm init and add webpack and webpack cli to bundle your simple web app (html, css, js).
- In package.json you should create a ‘start’ script to use ‘webpack’.
- By default by just mentioning 
```json
{
	“start”: “webpack”
}
```
- This will use the default webpack config of finding the entry path as index.js in src folder and creating a prod bundle in dist folder.
- And make sure you use es6 import and export to tell webpack to manage dependency. 
- After these changes you just include the one main.js file generated by webpack in dist folder instead of including all the files.
- Create your own webpack config file.
- Name can be anything it doesn’t matter.


```js
    const path = require("path");
    
    module.exports = {
        mode: "development", // Makes sure source code is not minified.
        entry: ".src/index.js",
        output: {
            filename: "main.js",
            path: path.resolve(__dirname, "dist")
        }
    };

	
```


- Till now we were able to create the bundle of all over JS code what about css and images?
- How do we handle those? We use something called loaders to achieve that. 
- Let's start with css.
- We make use of something called css-loader and style-loader to achieve that. 

  - - css-loader: Responsible for converting css into JS. Which alone is not that useful. That is where style-loader comes into picture it takes that css converted into js and injects into the style tag (default behaviour). 

```js
...
    module: {
        rules: [
        {
            test: /\.css$/,
            use: ["style-loader", "css-loader"]
        }
        ]
    }
```

Note that the order of style-loader and css-loader matters here. Loaders are read from right to left. You want css-loader to pick up the .css file convert that and then style-loader to kick in to place that css content in the style tag. 



- How to import boostrap using scss
- npm/yarn add boostrap
- And import bootstrap using import syntax. 


```
    $primary: teal; // Overriding bootstrap colors.
    @import "~/bootstrap/scss/boostrap"; // importing bootstrap using scss.

```

- scss loader

```js
    rules: [
    ...
    {
        test: /\.scss$/,
        use: [
        "style-loader", 
        "css-loader", 
        "sass-loader"
        ]
        // Order matters here. Loaders are read right to left.
        // 1. sass-loader - convert scss into css. (It makes use of node-sass to do that.)
        // 2. css-loader - Turns css to commonjs. Which means converting css to js. 
        // 3. style-loader - Which is responsible for taking that css converted into js to injecting it in the DOM.
      }
    }
    
    ]

```

- cache busting: It is done using contentHash. 
- As long as content doesn't change contentHash doesn't change. (Uses md5 hash behind the scene)
- Usage

```js
    module.exports = {
        ...
        output: {
            filename: "main.[contentHash].js",
            ...
        }
    }
```

 - After doing this how do we inject this into our public html page. Its keeps changing we can't predict this. 
 - That is where plugins comes into play. 
 - We make use of a plugin to create the html page for us with script tag to include our (cache-busted) js file.
 - We use HtmlWebpackPlugin to achieve this. 
 - 

```js
    module.exports = {
        ...
        output: {
            ...
        },
        plugins: [
            new HtmlWebpackPlugin({
            
                template: "./public/index.html"
            })
        ]
    }
```

- With template config you are saying use my ./public/index.html and add relevant script tag at the end to link my js file. 
- If we don't specify it will create boilerplate html file with script tag added at the end. 


- Till now we had only one webpack file, which is not ideal, generally we make one webpack for development and one for production. 
- But while doing that we may encounter that most of the things might be common between them. Since we follow DRY we don't want to duplicate the code. - In order to address that we create 3 files 
    - webpack.dev.js
    - webpack.prod.js
    - webpack.common.js

- We put all the common config in webpack.common.js and dev and prod specific things in their respective files.
- With that out of the way, how do we combine now? 
- We make use of the package called wepack-merge to achieve that.
- Now if we don't want to keep running npm/yarn start each time we make some change to the code, we can make use of dev-server which is similar nodemon for node. 
- To do that we install webpack-dev-server and use that instead of webpack in start script. 

```json
    "scripts": {
        "start": "webpack-dev-server --config webpack.dev.js --open",
        "build": "webpack --config webpack.prod.js"
    }
```

- One nice thing about webpack-dev-server is that it create all the files in-memory, while webpack spits it out as dist folder. 
- 